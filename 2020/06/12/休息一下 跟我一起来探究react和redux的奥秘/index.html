

<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>休息一下 跟我一起来探究react和redux的奥秘 - Paige&#39;s XSpace</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="google" content="notranslate" />
  <meta name="referrer" content="no-referrer" />
  
  <meta name="keywords" content="zhaoo, hexo-theme-zhaoo,"> 
  
  <meta name="description" content="tech blog about web develop,React 是什么React 是一个声明式，高效且灵活..."> 
  
  <meta name="author" content="zhangyp"> 

  
    <link rel="icon" href="/images/icons/favicon-16x16.png" type="image/png" sizes="16x16">
  
  
    <link rel="icon" href="/images/icons/favicon-32x32.png" type="image/png" sizes="32x32">
  
  
    <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png" sizes="180x180">
  
  
    <meta rel="mask-icon" href="/images/icons/stun-logo.svg" color="#333333">
  
  
    <meta rel="msapplication-TileImage" content="/images/icons/favicon-144x144.png">
    <meta rel="msapplication-TileColor" content="#000000">
  

  
<link rel="stylesheet" href="/css/style.css">


  
  
<link rel="stylesheet" href="//at.alicdn.com/t/font_1445822_58xq2j9v1id.css">

  

  
  
  
<link rel="stylesheet" href="https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.css">

  

  
  
  
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/dracula.min.css">

  

  
  
  
<link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css">

  

  <script>
    var CONFIG = window.CONFIG || {}
    CONFIG = {
      fancybox: true,
      pjax: false,
      lazyload: {
        enable: true,
        loadingImage: '/images/theme/loading.gif',
      },
      donate_alipay: 'http://img.u-to-world.com/blog/alipay.png',
      donate_wechat: 'http://img.u-to-world.com/blog/weixinpay.png',
      motto: {
        api: 'http://api.lovelive.tools/api/SweetNothings',
        default: '不要温和地走进那良夜'
      },
      galleries: {
        enable: 'true'
      },
      fab: {
        enable: 'true',
        alwaysShow: 'false'
      }
    }
  </script>

  

  
<meta name="generator" content="Hexo 4.2.1"></head>

<body class="lock-screen">
  <div class="loading"></div>
  <nav class="menu">
  <div class="menu-close">
    <i class="iconfont iconplus"></i>
  </div>
  <ul class="menu-content">
    
    
    
    
    <li class="menu-item"><a href="/ "> 首页</a></li>
    
    
    
    
    <li class="menu-item"><a href="http://u-to-world.com:8080/index.html " target="_blank" rel="noopener"> 作品(我的音乐)</a></li>
    
    
    
    
    <li class="menu-item"><a href="/archives "> 归档</a></li>
    
    
    
    
    <li class="menu-item"><a href="/tags "> 标签</a></li>
    
    
    
    
    <li class="menu-item"><a href="/categories "> 分类</a></li>
    
    
    
    
    <li class="menu-item"><a href="/about "> 关于</a></li>
    
  </ul>
  <div class="menu-copyright"><p>Copyright© 2019-2020 | <a target="_blank" href="http://blog.u-to-world.com">小笼包</a> .AllRightsReserved</p></div>
</nav>
  <main id="main">
  <div class="container" id="container">
    <article class="article">
  <section class="head">
  <img   class="lazyload" data-original="/images/theme/post-img.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  draggable="false">
  <div class="head-mask">
    <h1 class="head-title">休息一下 跟我一起来探究react和redux的奥秘</h1>
    <div class="head-info">
      <span class="post-info-item"><i class="iconfont iconcalendar"></i>2020-06-12</span
        class="post-info-item">
      
      <span class="post-info-item"><i class="iconfont iconfont-size"></i>4613</span>
    </div>
  </div>
</section>
  <section class="main">
    <section class="content">
      <p><strong>React 是什么</strong><br>React 是一个声明式，高效且灵活的用于构建用户界面的 JavaScript 库。使用 React 可以将一些简短、独立的代码片段组合成复杂的 UI 界面，这些代码片段被称作“组件”。</p>
<h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a><strong>组件化</strong></h2><ol>
<li>React 组件由视图和本身状态 state，以及外部传入 props 构成 在 render 函数中用 jsx 来创建虚拟 dom。</li>
<li>setState 方法会改变组件内部状态，然后调用 render 函数 改变虚拟 dom，react 再通过 mount 函数进行虚拟 dom 到实际 dom 的印射。</li>
<li>如果外部传入的 props 发生变化，会先从 willReceiveProps 开始，再到 shouldComponentUpdate,这个钩子里面可以进行新 props 和旧的 props 的对比，一致就 return false 表示不去更新 否则在走更新流程。</li>
<li>组件就是拥有独立功能的视图模块，许多小的组件组成一个大的组件，整个页面就是由一个个组件组合而成。它的好处是利于重复利用和维护。</li>
</ol>
<h2 id="Diff-算法"><a href="#Diff-算法" class="headerlink" title="Diff 算法"></a><strong>Diff 算法</strong></h2><p><strong><img   class="lazyload" data-original="https://cdn.nlark.com/yuque/0/2020/png/1512483/1591942890711-67e7c93d-d0ae-4168-a826-e656ab3dc6a3.png#align=left&display=inline&height=307&margin=%5Bobject%20Object%5D&name=diff.png&originHeight=307&originWidth=556&size=56260&status=done&style=none&width=556" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="diff.png"></strong></p>
<ol>
<li>当组件更新的时候，react 会创建一个新的虚拟 dom 树并且会和之前储存的 dom 树进行比较，这个比较多过程就用到了 diff 算法。</li>
<li>react 提出了一种假设，相同的节点具有类似的结构，而不同的节点具有不同的结构。在这种假设之上进行逐层的比较，如果发现对应的节点是不同的，那就直接删除旧的节点以及它所包含的所有子节点然后替换成新的节点。如果是相同的节点，则只进行属性的更改。</li>
<li>对于列表的 diff 算法稍有不同，因为列表通常具有相同的结构，在对列表节点进行删除，插入，排序的时候，单个节点的整体操作远比一个个对比一个个替换要好得多，所以在创建列表的时候需要设置 key 值，这样 react 才能分清谁是谁。当然不写 key 值也可以，但这样通常会报出警告，通知我们加上 key 值以提高 react 的性能。</li>
</ol>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a><strong>生命周期</strong></h2><p><img   class="lazyload" data-original="https://cdn.nlark.com/yuque/0/2020/png/1512483/1591942867704-6e64b1bf-3148-4705-8341-9925d14ad31f.png#align=left&display=inline&height=622&margin=%5Bobject%20Object%5D&name=lifecycle.png&originHeight=622&originWidth=605&size=108579&status=done&style=none&width=605" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="lifecycle.png"><br>组件在初始化时会触发 5 个钩子函数：</p>
<h3 id="1-getDefaultProps"><a href="#1-getDefaultProps" class="headerlink" title="1.getDefaultProps()"></a>1.getDefaultProps()</h3><p>设置默认的 props，也可以用 dufaultProps 设置组件的默认属性。</p>
<h3 id="2-getInitialState"><a href="#2-getInitialState" class="headerlink" title="2.getInitialState()"></a>2.getInitialState()</h3><p>在使用 es6 的 class 语法时是没有这个钩子函数的，可以直接在 constructor 中定义 this.state。此时可以访问 this.props。</p>
<h3 id="3-componentWillMount"><a href="#3-componentWillMount" class="headerlink" title="3.componentWillMount()"></a>3.componentWillMount()</h3><p>组件初始化时只调用，以后组件更新不调用，整个生命周期只调用一次，此时可以修改 state。</p>
<h3 id="4-render"><a href="#4-render" class="headerlink" title="4. render()"></a>4. render()</h3><p>react 最重要的步骤，创建虚拟 dom，进行 diff 算法，更新 dom 树都在此进行。此时就不能更改 state 了。</p>
<h3 id="5-componentDidMount"><a href="#5-componentDidMount" class="headerlink" title="5.componentDidMount()"></a>5.componentDidMount()</h3><p>组件渲染之后调用，只调用一次。<br>在更新时也会触发 5 个钩子函数：</p>
<h3 id="6-componentWillReceivePorps-nextProps"><a href="#6-componentWillReceivePorps-nextProps" class="headerlink" title="6.componentWillReceivePorps(nextProps)"></a>6.componentWillReceivePorps(nextProps)</h3><p>组件初始化时不调用，组件接受新的 props 时调用。</p>
<h3 id="7-shouldComponentUpdate-nextProps-nextState"><a href="#7-shouldComponentUpdate-nextProps-nextState" class="headerlink" title="7.shouldComponentUpdate(nextProps, nextState)"></a>7.shouldComponentUpdate(nextProps, nextState)</h3><p>react 性能优化非常重要的一环。</p>
<ol>
<li>组件接受新的 state 或者 props 时调用，我们可以设置在此对比前后两个 props 和 state 是否相同，如果相同则返回 false 阻止更新，因为相同的属性状态一定会生成相同的 dom 树，这样就不需要创造新的 dom 树和旧的 dom 树进行 diff 算法对比，节省大量性能，尤其是在 dom 结构复杂的时候。不过调用 this.forceUpdate 会跳过此步骤。</li>
<li>也可以使用 pureComponent，不过这边是对于 props 和 state 是浅比较，只对第一层 key 的个数，名称，引用进行比较，所以我们如果 value 是数组或对象改变时要用展开符或者 concat 来改变引用 触发更新</li>
</ol>
<h3 id="8-componentWillUpdata-nextProps-nextState"><a href="#8-componentWillUpdata-nextProps-nextState" class="headerlink" title="8.componentWillUpdata(nextProps, nextState)"></a>8.componentWillUpdata(nextProps, nextState)</h3><p>组件初始化时不调用，只有在组件将要更新时才调用，此时可以修改 state</p>
<h3 id="9-render"><a href="#9-render" class="headerlink" title="9.render()"></a>9.render()</h3><p>不多说<br>10.componentDidUpdate()<br>组件初始化时不调用，组件更新完成后调用，此时可以获取 dom 节点。<br>还有一个卸载钩子函数<br>11.componentWillUnmount()<br>组件将要卸载时调用，一些事件监听和定时器需要在此时清除。<br>以上可以看出来 react 总共有 10 个周期函数（render 重复一次），这个 10 个函数可以满足我们所有对组件操作的需求，利用的好可以提高开发效率和组件性能。</p>
<h1 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a><strong>Redux</strong></h1><p><img   class="lazyload" data-original="https://cdn.nlark.com/yuque/0/2020/png/1512483/1591942973389-1b124061-f781-4b8f-8f43-98c6feccadb0.png#align=left&display=inline&height=356&margin=%5Bobject%20Object%5D&name=redux.png&originHeight=356&originWidth=658&size=89512&status=done&style=none&width=658" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="redux.png"></p>
<p>redux 主要由三部分组成 :store,reducer,action</p>
<h2 id="a-store"><a href="#a-store" class="headerlink" title="a.store"></a>a.store</h2><h3 id="1-dispatch"><a href="#1-dispatch" class="headerlink" title="1.dispatch"></a>1.dispatch</h3><p>用于 action 的分发——在 createStore 中可以用 middleware 中间件对 dispatch 进行改造，比如当 action 传入 dispatch 会立即触发 reducer，有些时候我们不希望它立即触发，而是等待异步操作完成之后再触发，这时候用 redux-thunk 对 dispatch 进行改造，以前只能传入一个对象，改造完成后可以传入一个函数，在这个函数里我们手动 dispatch 一个 action 对象，这个过程是可控的，就实现了异步。</p>
<h3 id="2-subscribe"><a href="#2-subscribe" class="headerlink" title="2.subscribe"></a>2.subscribe</h3><p>监听 state 的变化——这个函数在 store 调用 dispatch 时会注册一个 listener 监听 state 变化，当我们需要知道 state 是否变化时可以调用，它返回一个函数，调用这个返回的函数可以注销监听。<br>let unsubscribe = store.subscribe(() =&gt; {console.log(‘state 发生了变化’)})</p>
<h3 id="3-getState"><a href="#3-getState" class="headerlink" title="3.getState"></a>3.getState</h3><p>获取 store 中的 state——当我们用 action 触发 reducer 改变了 state 时，需要再拿到新的 state 里的数据，毕竟数据才是我们想要的。getState 主要在两个地方需要用到，一是在 dispatch 拿到 action 后 store 需要用它来获取 state 里的数据，并把这个数据传给 reducer，这个过程是自动执行的，二是在我们利用 subscribe 监听到 state 发生变化后调用它来获取新的 state 数据，如果做到这一步，说明我们已经成功了。</p>
<h2 id="b-action"><a href="#b-action" class="headerlink" title="b.action"></a>b.action</h2><p>action 是一个对象，其中 type 属性是必须的，同时可以传入一些数据。action 可以用 actionCreactor 进行创造。dispatch 就是把 action 对象发送出去。</p>
<h2 id="c-reducer"><a href="#c-reducer" class="headerlink" title="c.reducer"></a>c.reducer</h2><p>reducer 是一个函数，它接受一个 state 和一个 action，根据 action 的 type 返回一个新的 state。根据业务逻辑可以分为很多个 reducer，然后通过 combineReducers 将它们合并，state 树中有很多对象，每个 state 对象对应一个 reducer，state 对象的名字可以在合并时定义。</p>
<p>但是这样有个问题就是我们的组件有很多，可能层层嵌套，这样就要把 store 和 action 一层层的传下去 非常麻烦，所以为了简便，可以使用 react-redux</p>
<h2 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a><strong>react-redux</strong></h2><h2 id="store-的三大功能：dispatch，subscribe，getState-都不需要手动来写了。react-redux-帮我们做了这些，同时它提供了两个好基友-Provider-和-connect。"><a href="#store-的三大功能：dispatch，subscribe，getState-都不需要手动来写了。react-redux-帮我们做了这些，同时它提供了两个好基友-Provider-和-connect。" class="headerlink" title="store 的三大功能：dispatch，subscribe，getState 都不需要手动来写了。react-redux 帮我们做了这些，同时它提供了两个好基友 Provider 和 connect。"></a>store 的三大功能：dispatch，subscribe，getState 都不需要手动来写了。react-redux 帮我们做了这些，同时它提供了两个好基友 Provider 和 connect。</h2><p>Provider 是一个组件，它接受 store 作为 props，然后通过 context 往下传，这样 react 中任何组件都可以通过 contex 获取 store。也就意味着我们可以在任何一个组件里利用 dispatch(action)来触发 reducer 改变 state，并用 subscribe 监听 state 的变化，然后用 getState 获取变化后的值。但是并不推荐这样做，它会让数据流变的混乱，过度的耦合也会影响组件的复用，维护起来也更麻烦。<br>connect(mapStateToProps, mapDispatchToProps, mergeProps, options)是一个函数，它接受四个参数并且再返回一个函数 wrapWithConnect，wrapWithConnect 接受一个组件作为参数 wrapWithConnect(component)，它内部定义一个新组件 Connect(容器组件)并将传入的组件(ui 组件)作为 Connect 的子组件然后 return 出去。<br>所以它的完整写法是这样的：connect(mapStateToProps, mapDispatchToProps, mergeProps, options)(component)</p>
<h3 id="1-mapStateToProps-接受两个参数，store-的-state-和自定义的-props，并返回一个新的对象，这个对象会作为-props-的一部分传入-ui-组件。我们可以根据组件所需要的数据自定义返回一个对象。"><a href="#1-mapStateToProps-接受两个参数，store-的-state-和自定义的-props，并返回一个新的对象，这个对象会作为-props-的一部分传入-ui-组件。我们可以根据组件所需要的数据自定义返回一个对象。" class="headerlink" title="1.mapStateToProps 接受两个参数，store 的 state 和自定义的 props，并返回一个新的对象，这个对象会作为 props 的一部分传入 ui 组件。我们可以根据组件所需要的数据自定义返回一个对象。"></a>1.mapStateToProps 接受两个参数，store 的 state 和自定义的 props，并返回一个新的对象，这个对象会作为 props 的一部分传入 ui 组件。我们可以根据组件所需要的数据自定义返回一个对象。</h3><p>mapStateToProps(state){return{ todos: state.todos };}</p>
<h3 id="2-mapDispatchToProps-dispatch-ownProps"><a href="#2-mapDispatchToProps-dispatch-ownProps" class="headerlink" title="2.mapDispatchToProps(dispatch, [ownProps])"></a>2.mapDispatchToProps(dispatch, [ownProps])</h3><p>mapDispatchToProps 如果是对象，那么会和 store 绑定作为 props 的一部分传入 ui 组件。如果是个函数，它接受两个参数，bindActionCreators 会将 action 和 dispatch 绑定并返回一个对象，这个对象会和 ownProps 一起作为 props 的一部分传入 ui 组件。所以不论 mapDispatchToProps 是对象还是函数，它最终都会返回一个对象，如果是函数，这个对象的 key 值是可以自定义的</p>
<h3 id="3-mergeProps-stateProps-dispatchProps-ownProps"><a href="#3-mergeProps-stateProps-dispatchProps-ownProps" class="headerlink" title="3. mergeProps(stateProps,dispatchProps,ownProps)"></a>3. mergeProps(stateProps,dispatchProps,ownProps)</h3><p>将 mapStateToProps() 与 mapDispatchToProps()返回的对象和组件自身的 props 合并成新的 props 并传入组件。默认返回 Object.assign({}, ownProps, stateProps, dispatchProps) 的结果。</p>
<h3 id="4-options"><a href="#4-options" class="headerlink" title="4.options"></a>4.options</h3><p>pure = true 表示 Connect 容器组件将在 shouldComponentUpdate 中对 store 的 state 和 ownProps 进行浅对比，判断是否发生变化，优化性能。为 false 则不对比。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a><strong>结语</strong></h1><p>写了这么多，真正要掌握还是要在工作当中多用，多尝试，如果文中有错误之处，欢迎交流指正。<br>**</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a><strong>参考</strong></h1><p><a href="https://react.docschina.org/" target="_blank" rel="noopener">https://react.docschina.org</a><br><a href="https://www.redux.org.cn/" target="_blank" rel="noopener">https://www.redux.org.cn/</a></p>

    </section>
    <section class="extra">
      
        <section class="donate">
  <div class="qrcode">
    <img   class="lazyload" data-original="http://img.u-to-world.com/blog/alipay.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" >
  </div>
  <div class="icon">
    <a href="javascript:;" id="alipay"><i class="iconfont iconalipay"></i></a>
    <a href="javascript:;" id="wechat"><i class="iconfont iconwechat-fill"></i></a>
  </div>
</section>
      
      
      
<nav class="nav">
  
    <a href="/2020/06/12/%E8%87%AA%E5%AE%9A%E4%B9%89hooks%E8%B8%A9%E5%9D%91%E8%AE%B0%E2%80%94%E2%80%94treeSelect%E7%BB%84%E4%BB%B6%E9%80%BB%E8%BE%91%E5%B0%81%E8%A3%85/"><i class="iconfont iconleft"></i>自定义hooks踩坑记——treeSelect组件逻辑封装</a>
  
  
    <a href="/2020/06/06/%E8%AE%B0iphone%208p%E6%8D%A2%E5%90%8E%E5%B1%8F%E9%82%A3%E7%82%B9%E4%BA%8B%E5%84%BF/">记iphone 8p换后屏那点事儿<i class="iconfont iconright"></i></a>
  
</nav>

    </section>
    
      <section class="comments">
        
          <div class="btn" id="comments-btn">查看评论</div>
        
        
<div id="valine"></div>
<script defer src="//cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js"></script>
<script>
  window.onload = function () {
    var loadValine = function () {
      new Valine({
        el: '#valine',
        app_id: "XgHS51JuLkeipj92BK4KyIEI-gzGzoHsz",
        app_key: "LHxBDnRt6RQCuByhRfp1pkVN",
        placeholder: "ヾﾉ≧∀≦)o来啊，快活啊!",
        avatar: "mp",
        pageSize: "10",
        lang: "zh-CN",
      });
    }
    if ( true ) {
      $("#comments-btn").on("click", function () {
        $(this).hide();
        loadValine();
      });
    } else {
      loadValine();
    }
  };
</script>


      </section>
    
  </section>
</article>
  </div>
</main>
  <footer class="footer">
  <div class="footer-social">
    
    
    
    
    
    <a href="tencent://message/?Menu=yes&uin=694534942 " target="_blank" onMouseOver="this.style.color= '#12B7F5'"
      onMouseOut="this.style.color='#33333D'">
      <i class="iconfont footer-social-item  iconQQ "></i>
    </a>
    
    
    
    
    
    <a href="javascript:; " target="_blank" onMouseOver="this.style.color= '#09BB07'"
      onMouseOut="this.style.color='#33333D'">
      <i class="iconfont footer-social-item  iconwechat-fill "></i>
    </a>
    
    
    
    
    
    <a href="https://www.instagram.com/izhaoo/ " target="_blank" onMouseOver="this.style.color= '#DA2E76'"
      onMouseOut="this.style.color='#33333D'">
      <i class="iconfont footer-social-item  iconinstagram "></i>
    </a>
    
    
    
    
    
    <a href="https://github.com/godlikedeveloper " target="_blank" onMouseOver="this.style.color= '#24292E'"
      onMouseOut="this.style.color='#33333D'">
      <i class="iconfont footer-social-item  icongithub-fill "></i>
    </a>
    
    
    
    
    
    <a href="mailto:694534942@qq.com " target="_blank" onMouseOver="this.style.color='#FFBE5B'"
      onMouseOut="this.style.color='#33333D'">
      <i class="iconfont footer-social-item  iconmail"></i>
    </a>
    
  </div>
  <div class="footer-copyright"><p>Copyright© 2019-2020 | <a target="_blank" href="http://blog.u-to-world.com">小笼包</a> .AllRightsReserved</p></div>
</footer>
  
      <div class="fab fab-plus">
    <i class="iconfont iconplus"></i>
  </div>
  <div class="fab fab-up">
    <i class="iconfont iconcaret-up"></i>
  </div>
  <div class="fab fab-menu">
    <i class="iconfont iconmenu"></i>
  </div>
  
</body>


<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>






<script src="https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.js"></script>








<script src="https://cdn.bootcdn.net/ajax/libs/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>






<script src="https://cdn.bootcdn.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js"></script>






<script src="/js/script.js"></script>



<script>
  (function () {
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
      bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    } else {
      bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
  })();
</script>











</html>